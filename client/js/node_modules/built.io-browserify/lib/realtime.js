/*TO DO
  When 2 apps are made with same api key realtime stops working
  off method doesnot support broadcast.
  For built_io_application_user the socket.on is invoked twice from the server side
  when a listner is attached on Class.Object we should cache objects so that we dnt have to fetch object from built.io
  getPresence method should accept a fetch args which will get presence form server else would return _presence if available.
*/
var R                     = require('ramda');
var utility               = require('./utilities/utility');
var instanceMethodBuilder = require('./utilities/instanceMethodBuilder')();
var Diff                  = require('./utilities/diff');
var io                    = require('socket.io-client');
var when                  = require('when');
var Built                 = require('./built');
var constants             = require('./constants');
/*
The below given self invoking method would register real time plugin.
*/
pluginsHelper.registerPlugin("realtime",{
  onAppInstance: function(app) {

    app.enableRealtime      = enableRealtime;

    app.disableRealtime     = disableRealtime; 

    app.isRealtimeEnabled   = isRealtimeEnabled;

    app.onRealtimeError     = onRealtimeError;

    app.authorizeSocket     = authorization;

    app.addMetaMapp         = function(){
      return addSocketDataInAppOptions('metaMap',{},this);
    };
    app.addAdhocOpterations = function(){
      return addSocketDataInAppOptions('adhocOperations',[],this);
    };
    app.setAuthStarted      = function(value){
      return addSocketDataInAppOptions('authStarted',value,this);
    };
    app.setSocket           = function(value){
      return addSocketDataInAppOptions('socket',value,this);
    };
    app.getSocket           = function(value) {
      if(this.getOptions().socketData){
        return this.options.socketData.socket
      }else{
        return null;
      }
    }  
    app.isSocketConnected   = function() {
     // 2 time '.socket' as socket object itself has a socket property
      if(this.isRealtimeEnabled && this.isRealtimeEnabled()){
        return this.getOptions().socketData.socket.connected //changed
        // return this.getOptions().socketData.socket.socket.connected
      }else{
        return null;
      }
    }
    app.getMetaMap          = function(){
      if(this.isRealtimeEnabled && this.isRealtimeEnabled()){
        return this.getOptions().socketData.metaMap;
      }else{
        return null;
      }
    };
    app.getAdhocOperations  = function(){
      if(this.isRealtimeEnabled && this.isRealtimeEnabled()){
        return this.getOptions().socketData.adhocOperations;
      }else{
        return null;
      }
    }
    app.isSocketAuthStarted = function(){
      if(this.isRealtimeEnabled && this.isRealtimeEnabled()){
        return this.getOptions().socketData.authStarted;
      }else{
        return null;
      }
    }
    /*app.getURLForRealtime = function(){
      var options = this.getOptions();
      return options.protocol + '://' + options.host;
    }*/
    app.getURLForRealtime = function(){
      return this.getOption('rtProtocol') + '://' + this.getOption('rtHost') + ':' + this.getOption('rtPort') + '/' + this.getApiKey();
    }
  },
  onObjectInstance: function(object) {
    object.on           = setupInstListener('object');
    object.off          = utility.wrapper(removeInstListener('object'),[null,null]);
    object.broadcast    = broadcastInstMessage('object');
  },
  onObjectCons : function(cls){
   var channel          = "notifications."+cls.uid+".object"
   cls.Object.on        = setupConsListener(cls.app,channel);
   cls.Object.off       = utility.wrapper(removeConsListener(cls.app,channel),[null,null]);
   cls.Object.broadcast = broadcastMessageForCons(cls.app,channel);
  },
  onClassCons : function(app){
    var channel          = "notifications.class";
    app.Class.on         = setupConsListener(app,channel);
    app.Class.off        = utility.wrapper(removeConsListener(app,channel),[null,null]);
    app.Class.broadcast  = broadcastMessageForCons(app,channel);
  },
  onClassInstance: function(classInst){
    classInst.on        = setupInstListener('class');
    classInst.off       = utility.wrapper(removeInstListener('class'),[null,null]);
    classInst.broadcast = broadcastInstMessage('class');
  },
  onUploadCons : function(app){
    var channel          = "notifications.upload";
    app.Upload.on        = setupConsListener(app,channel);
    app.Upload.off       = utility.wrapper(removeConsListener(app,channel),[null,null]);
    app.Upload.broadcast = broadcastMessageForCons(app,channel);
  },
  onUploadInstance: function(upload){
    upload.on           = setupInstListener('upload');
    upload.off          = utility.wrapper(removeInstListener('upload'),[null,null]);
    upload.broadcast    = broadcastInstMessage('upload');
  },
  onUserCons: function(app){
    var loginFn             = app.User.login;
    var loginWithGoogleFn   = app.User.loginWithGoogle;
    var loginWithFacebookFn = app.User.loginWithFacebook;
    var loginWithTibbrFn    = app.User.loginWithTibbr;
    var loginWithTwitterFn  = app.User.loginWithTwitter;
    var logoutFn            = app.User.logout;
    var channel             = "notifications." + constants.APP_USER_CLS +".object";
    app.User.on             = setupConsListener(app,channel);
    app.User.off            = utility.wrapper(removeConsListener(app,channel),[null,null]);
    app.User.broadcast      = broadcastMessageForCons(app,channel);
    app.User.getPresence = function(){
      return socketEmit('getPresence', {
      }, app);
    };
    app.User.login             = function(email, password, user){
      return loginHelper(loginFn, email, password, user);
    };
    app.User.logout            = function(user){
      return logoutHelper(logoutFn,user);
    };
    app.User.loginWithGoogle   = function(access_token,user){
      return loginWithGoogleHelper(loginWithGoogleFn, access_token, user);
    };
    app.User.loginWithFacebook = function(access_token,user){
      return loginWithFacebookHelper(loginWithFacebookFn, access_token, user);
    };
    app.User.loginWithTibbr    = function(access_token, hostname, user){
      return loginWithTibbrHelper(loginWithTibbrFn, access_token, hostname, user);
    };
    app.User.loginWithTwitter  = function(token, token_secret, consumer_key, consumer_secret, user){
      return loginWithTwitterHelper(loginWithTwitterFn ,token, token_secret, consumer_key, consumer_secret, user)
    }
  },
  onUserInstance: function(user) {
    var loginFn             = user.login;
    var loginWithGoogleFn   = user.loginWithGoogle;
    var loginWithFacebookFn = user.loginWithFacebook;
    var loginWithTibbrFn    = user.loginWithTibbr;
    var loginWithTwitterFn  = user.loginWithTwitterT;
    var logoutFn            = user.logout;
    user.getPresence  = function() {
      if (!this.getUid())
        throw new Error("Uid not found");
      return socketEmit('getPresence', {
        application_user: this.getUid()
      }, user.app);
    };
    user.requestPresenceAccess = function() {
      if (!this.getUid())
        throw new Error("Uid not found");
      return socketEmit('requestPresence', {
        application_user: this.getUid()
      }, user.app);
    };
    user.login             = function(email, password) {
      var userObj = this;
      return loginHelper(loginFn, email, password, userObj);
    };
    user.logout            = function(){
      var userObj = this;
      return logoutHelper(logoutFn,userObj);
    };
    user.loginWithGoogle   = function(access_token){
      return loginWithGoogleHelper(loginWithGoogleFn, access_token, this);
    };
    user.loginWithFacebook = function(access_token){
      return loginWithFacebookHelper(loginWithFacebookFn, access_token, this);
    };
    user.loginWithTibbr    = function(access_token, hostname){
      return loginWithTibbrHelper(loginWithTibbrFn, access_token, hostname, this);
    };
    user.loginWithTwitter  = function(token, token_secret, consumer_key, consumer_secret){
      return loginWithTwitterHelper(loginWithTwitterFn, token, token_secret, consumer_key, consumer_secret, this);
    }
  },
  onRoleCons: function(app){
    var channel        = "notifications." + constants.APP_ROLE_CLS +".object";
    app.Role.on        = setupConsListener(app,channel);
    app.Role.off       = utility.wrapper(removeConsListener(app,channel),[null,null]);
    app.Role.broadcast = broadcastMessageForCons(app,channel);
  },
  onInstallationCons: function(app){
    var channel                = "notifications." + constants.APP_INSTALLATION_CLS +".object";
    app.Installation.on        = setupConsListener(app,channel);
    app.Installation.off       = utility.wrapper(removeConsListener(app,channel),[null,null]);
    app.Installation.broadcast = broadcastMessageForCons(app,channel);
  }
});

function authorizeSocketAfterLogin(user) {
  if (user.app.isRealtimeEnabled && user.app.isRealtimeEnabled())
    return authorization(user.app).yield(user);
  else
    return user;
}

function loginHelper(loginFn, email, password, userObj) {
  return loginFn(email, password, userObj)
    .then(function(user) {
      return authorizeSocketAfterLogin(user);
    });
}

function loginWithGoogleHelper(actualFn, access_token,user){
  return actualFn(access_token, user)
    .then(function(user){
      return authorizeSocketAfterLogin(user);
    });
}

function loginWithFacebookHelper(actualFn, access_token,user){
  return actualFn(access_token, user)
    .then(function(user){
      return authorizeSocketAfterLogin(user);
    });
}

function loginWithTibbrHelper(actualFn, access_token, hostname, user){
  return actualFn(access_token, hostname, user)
    .then(function(user){
      return authorizeSocketAfterLogin(user);
    });
}

function loginWithTwitterHelper(actualFn, token, token_secret, consumer_key, consumer_secret, user){
  return actualFn(token, token_secret, consumer_key, consumer_secret, user)
    .then(function(user){
      return authorizeSocketAfterLogin(user);
    });
}

function logoutHelper(logoutFn, userObj) {
  return logoutFn(userObj)
    .then(function(user) {
      if(userObj.app.isRealtimeEnabled())
        return authorization(userObj.app).yield(user);
      else
        return user;
    });
}

var broadcastInstMessage = R.curry(function(type,message){
  return broadcastMessageForCons.bind(this)(this.app, generateChannelForInst(type, this), message);
});

var broadcastMessageForCons = R.curry(function(app, channel, message) {
  var self                  = this;
  var socket                = app.getSocket();
  var subsriberStr          = 'subscription.' + channel;
  var curriendBroadcastEmit = broadcastEmit(channel,message,app);

  // If master key is present in app headers, subscription is not required so we can directly make a broadcast on that channel
  if(app.getMasterKey()){
    if(app.isSocketConnected()){
      return curriendBroadcastEmit(socket)
    }else{
      return app.getAdhocOperations().push(curriendBroadcastEmit);
    }
  }

  if (!app.getMetaMap()[subsriberStr]) {  //Checks we already have a subscriber for this channel
    storeSubscriberInMap(app, channel, subsriberStr);
  }
  if (app.isSocketConnected()) {
    app.getMetaMap()[subsriberStr](socket) // install the subscriber
    .then(function(){
      curriendBroadcastEmit(socket);
    });
  }else{
    app.getAdhocOperations().push(curriendBroadcastEmit);
  }
  return self;
});

var broadcastEmit = R.curry(function(channel,message,app,socket){
  socket.emit('broadcast', {
          channel : channel,
          data    : message
        }, function(error) {
          if (!error)
            console.log('broadcast done');
          if (error && app.getMetaMap().errorHandler)
            app.getMetaMap().errorHandler(error);
        })
});



function addSocketDataInAppOptions(parameter, value, app) {
  var options               = app.getOptions();
  var newSocketData         = R.mixin({}, options.socketData)
  newSocketData[parameter]  = value;
  options['socketData']     = newSocketData;
  return app.setOptions(options, app);
}

var socketEmit = R.curry(function(string, payload, app) {
  var deferred = when.defer();
  function emitFn(socket) {
    socket.emit(string, payload, function(err, data) {
      if (err) {
        deferred.reject(err);
      }
      if (!err || data) {
        deferred.resolve(Built.Presence(app, data.presence));
      }
    });
  }
  if (app.isSocketConnected()) {
    emitFn(app.getSocket(),deferred);
  } else {
    app.getAdhocOperations().push(emitFn);
  }
  return deferred.promise;
});

var setupInstListener = R.curry(function(type,parameter,callback){
  return setupConsListener.bind(this)(this.app,generateChannelForInst(type,this),parameter,callback);
});

var setupConsListener = R.curry(function(app, channel, parameter, callback) {
  var self = this;
  switch (parameter) {
    case 'presence':
      storeCallbackInMap(app, parameter, callback);
      break;
    case 'broadcast':
      registerConsBroadcast(app, channel, parameter, callback); // no break statement so subscriber is called
    default:
      registerConsSubscriber(app, channel, parameter, callback);
      break;
  }
  return self;
});

function registerConsBroadcast(app, channel, parameter, callback) {
  var broadcastStr = 'message.' + channel + "." + parameter;
  storeCallbackInMap(app, broadcastStr, callback);
}

function registerConsSubscriber(app,channel,parameter,callback){
  var socket       = app.getSocket();
  var channelStr   = 'channel.' + channel + '.' + parameter;
  var subsriberStr = 'subscription.' + channel;
  storeCallbackInMap(app, channelStr, callback);
  storeSubscriberInMap(app, channel, subsriberStr);
  if (app.isSocketConnected()) {
    app.getMetaMap()[subsriberStr](socket);
  }
}

function storeCallbackInMap(app, channelStr, callback) {
  var array = app.getMetaMap()[channelStr] || [];
  array.push(callback);
  app.getMetaMap()[channelStr] = array;
}

function storeSubscriberInMap(app, channel, subsriberStr) {
  var dataStr = 'cache.' + channel;
  app.getMetaMap()[subsriberStr] = function(socket) { //eg subscription.person.blt123.update
    var deferred = when.defer();
    socket.emit('subscribe', {
      channel: channel
    }, function(error, data) {
      if (!error && data && data.resource) {
        app.getMetaMap()[dataStr] = data.resource;
      }
      if (error && app.getMetaMap().errorHandler) { // if there was an error in subscription (no permission to read on the entity), 'error' will contain details
        app.getMetaMap().errorHandler(error);
      }
      deferred.resolve();
    });
    return deferred.promise;
  }
}

var removeInstListener = R.curry(function(type, parameter, callback) {
  return removeConsListener.bind(this)(this.app, generateChannelForInst(type,this), parameter, callback);
});

var removeConsListener = R.curry(function(app, channelName, parameter, callback) {
  var self = this;
  validateArguments(parameter,callback);

  if (callback === null && parameter === null) {
    removeAllCallbacks(channelName, app);
  } else if (callback === null) {
    removeAllCallbacksOnEventName(channelName, parameter, app);
  } else {
    if (parameter === 'broadcast') {
      removeBroadcastListener(app, channelName, parameter, callback);
    } else {
      unRegisterSubscriber(app, channelName, parameter, callback);
    }
  }
  var subsriberStr = 'subscription.' + channelName;
  removeSubscriber(app, channelName, subsriberStr);
  return self;
});


function validateArguments(parameter,callback) {
  if (utility.isFunction(parameter))
    throw new Error('Event name is missing');
}

function removeAllCallbacks(channelName, app) {
  var channelSubStr   = 'channel.' + channelName;
  var broadcastSubStr = 'message.' + channelName;
  Object
    .keys(app.getMetaMap())
    .map(function(key) {
      if (key.indexOf(channelSubStr) > -1 || key.indexOf(broadcastSubStr) > -1) {
        delete app.getMetaMap()[key];
      }
    });
}

function removeAllCallbacksOnEventName(channelName, parameter, app) {
  var channelSubStr = 'channel.' + channelName + '.' + parameter;
  var callback      = app.getMetaMap()[channelSubStr];
  if(callback)   // ignore if callback was not present
    delete app.getMetaMap()[channelSubStr];
}

function removeBroadcastListener(app, channelName, parameter, callback) {
  var subsriberStr = 'subscription.' + channelName;
  var broadcastStr = 'message.' + channelName + "." + parameter;
  removeSpecificCallback(broadcastStr, app, parameter, channelName, callback)
}

function unRegisterSubscriber(app, channelName, parameter, callback) {
  var subsriberStr = 'subscription.' + channelName;
  var channelStr   = 'channel.' + channelName + "." + parameter;
  removeSpecificCallback(channelStr, app, parameter, channelName, callback);
}

function removeSpecificCallback(channelStr, app, parameter, channelName, callback) {
  var array      = app.getMetaMap()[channelStr];
  if (array) {
    var index = array.indexOf(callback);
    array.splice(index, 1);
    if (array.length === 0) {
      delete app.getMetaMap()[channelStr]; // removes the channel entry from metaMaps  
    }
  }
}
/*
  Entry for subscriber should be removed when all channel related to it are removed
  ie 'channel.notifications.person.blt660deb3539a50407.update' was the only channel and then was removed
  so'subscription.notifications.person.blt660deb3539a50407' should be removed as well
*/
function removeSubscriber(app, channelName, subsriberStr) {
  var matchedObj = (R.pickBy(function(key) { // 
    if (key.indexOf('channel.' + channelName) > -1 || key.indexOf('message.'+channelName) > -1) {
      return true
    }
    return false;
  }, Object.keys(app.getMetaMap())));
  if (Object.keys(matchedObj).length === 0) {
    delete app.getMetaMap()[subsriberStr];
  }
}

function generateChannelForInst(type,entity) {
  if (!entity.isNew())
      throw new Error("Uid not found");
  switch (type) {
    case 'object':
      return "notifications." + entity.cls.uid + "." + entity.getUid();
      break;
    case 'class':
      return "notifications." + entity.uid;
      break;
    case 'upload':
      return "notifications.upload." + entity.getUid();
      break;
  }
}

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>
  Enables realtime connection, all request to server would done through a socket.
  @memberof App
  @function enableRealtime
  @instance
  @example
  var app = Built
              .App('api_key')
              .enableRealtime();
  @return {App}
*/
function enableRealtime(){
  var socketObj = connect(this);
  var newApp    = createAppWithSocket(socketObj,this)                         
  attachListeners(newApp);
  if(newApp.isAuthenticated() || newApp.getHeaders().master_key){
    newApp.getMetaMap()['authorization'] = authorization;
  }
  return newApp;
}

function connect(app) {
  var random = Math.ceil(Math.random()*100000);
  var url    = app.getURLForRealtime();
  var socket = io(url, {
    query: 'api_key=' + app.getApiKey() + "&conn_id=" + random
  });
  return socket;
}

function createAppWithSocket(socketObj, app) {
  var newApp             = app
                           .addAdhocOpterations()  //meta properties that hold information required for real time functionality
                           .addMetaMapp()
                           .setSocket(socketObj)  
                           .setAdaptor(Built.Adaptor.SOCKET); // sets a socket property in app and changes adaptor to socketAdaptor
  return newApp;
}

function setupRouters(newApp){
  setupRouter('create'   , newApp);
  setupRouter('update'   , newApp);
  setupRouter('delete'   , newApp);
  setupRouter('broadcast', newApp);
  setupRouter('presence' , newApp);
}

function setupRouter(parameter, newApp) {
  var socket = newApp.getSocket();
  switch (parameter) {
    case 'broadcast':
      socket.on(parameter,routerCallbackForBroadcast(parameter, newApp));
      break;
    case 'presence':
      socket.on(parameter, routerCallbackForPresence(parameter, newApp));
      break;
    default : 
      socket.on(parameter, routerCallbackForCUD(parameter, newApp));
      break;
  }
}

var routerCallbackForPresence = R.curry(function(parameter, newApp, data) {
    if (newApp.getMetaMap()[parameter]) {
      newApp.getMetaMap()[parameter]
        .map(function(callback) {
          // server returns a object consisting of presence property which is not required in SDK
          var rawPresence              = R.mixin({}, data.presence);
          rawPresence.application_user = data.application_user; 
          callback(Built.Presence(newApp, rawPresence)); 
        });
    }
});

var routerCallbackForBroadcast = R.curry(function(parameter, newApp, data) {
  var broadcastStr = 'message.' + data.channel + "." + parameter;
  if (newApp.getMetaMap()[broadcastStr]) {
    newApp.getMetaMap()[broadcastStr]
      .map(function(callback) {
        callback(data.resource);
      });
  }
});

var routerCallbackForCUD = R.curry(function(parameter, newApp, data) {
  var channelStr = "channel." + data.channel + "." + parameter;
  if (newApp.getMetaMap()[channelStr]) { // listener for event on object is registered in metaMap as follow notifications.person.blt01D.update 
    newApp.getMetaMap()[channelStr]
      .map(function(callback) {
        mergeData(parameter, data, newApp)
          .then(function(data) {
            callback(data);
          });
      });
  }
});

function mergeData(parameter, data, newApp) {
  switch (getType(data.channel)) {
    case 'objectInst':
      return objectWrapper(parameter, data, newApp);
      break;
    case 'object':
      return objectWrapper(parameter, data, newApp);
      break;
    case 'uploadInst':
      return uploadWrapper(parameter, data, newApp);
      break;
    case 'upload' :
      return uploadWrapper(parameter, data, newApp);
      break;
    default:
      return when.resolve(data.resource);
      break;
  }
}

function getType(channel) {
  if (channel.match("notifications.upload$")) {
    return "upload"
  } else if (channel.match("notifications\.class$")) {
    return "class";
  } else if (channel.match("notifications\.[a-z|0-9|_]+$")) {
    return 'classInst'
  } else if (channel.match("notifications\.[a-z|0-9|_]+\.object$")) {
    return "object";
  } else if (channel.match("notifications\.upload\.[a-z|0-9|_]+$")) {
    return "uploadInst";
  } else if (channel.match("notifications\.[a-z|0-9|_]+\.[a-z|0-9|_]+$")) {
    return 'objectInst';
  }
}

function uploadWrapper(parameter, data, newApp) {
  if (parameter === "delete") {
    return when.resolve(data.resource);
  } else {
    return when.resolve(newApp.UploadCons({}, data.resource, data.resource.uid));
  }
}

function objectWrapper(parameter, data, newApp) {
  var deferred = when.defer();
  var dataStr  = "cache." + data.channel;
  if (parameter === "update") {
    if (newApp.getMetaMap()[dataStr] && (newApp.getMetaMap()[dataStr]._version + 1 === data.version)) {
      deferred.resolve(newApp.Class(data.classuid).ObjectCons({}, {}, Diff.applyPatch(newApp.getMetaMap()[dataStr], data.resource), data.objectuid));
    } else {
      newApp
        .Class(data.classuid)
        .Object(data.objectuid)
        .includeOwner()
        .fetch()
        .then(function(object) {
          newApp.getMetaMap()[dataStr] = object.toJSON(); // updating the cache
          deferred.resolve(object);
        });
    }
  }else{ // for create and delete
    deferred.resolve(newApp.Class(data.classuid).ObjectCons({}, {}, data.resource, data.resource.uid));
  }
  return deferred.promise;
}


function attachListeners(newApp) {
  var socket          = newApp.getSocket();
  var socketGlobalNS  = socket.io.socket('/'); 
  socket.once('connect', function() {
    onConnect(newApp);
  });
  socket.on('reconnect', function() {
    console.log("reconnecting socket");
    onConnect(newApp);
  });
  socket.on('error', function(error) {
    if (newApp.getMetaMap().errorHandler)
      newApp.getMetaMap().errorHandler(error);
    console.log(error);
  });
  socketGlobalNS.on('error', function(error){
    if (newApp.getMetaMap().errorHandler)
      newApp.getMetaMap().errorHandler(error);
    console.log(error);
  })
}

function onConnect(newApp){
  console.log("Socket connected");
  var socket = newApp.getSocket();
  socket.removeAllListeners();
  socket.on('reconnect',function(){
    console.log("reconnecting");
    onConnect(newApp);
  });
  // Sets up listener for CUD and broadcast
  setupRouters(newApp);

  //Register subscriber with server
  var authPromise       = when.resolve()

  // Trys to authenticate the socket connection
  if(newApp.getMetaMap().authorization)
    authPromise = newApp
                    .getMetaMap()
                    .authorization(newApp);
   
  //On completion of subscription flushes all adhoc operations 
  authPromise
    .then(function() {
      return setupAllSubscribersPromise(newApp)
    })
    .then(function() {
      if (!newApp.isSocketAuthStarted()) { // Authentication process is not going to happen how so try to flush the operation
        flushAdhocOperation(newApp);
      }
    });
}

function authorization(app){
  var deferred         = when.defer();
  var socket           = app.getSocket();
  var emitObj          = {};


  if(app.getAuthToken())
    emitObj['authtoken'] = app.getAuthToken();
  if(app.getMasterKey())
    emitObj['master_key'] = app.getMasterKey();
  
  //Authentication started flag enabled
  app.setAuthStarted(true);

  socket.emit('auth',
    emitObj
    ,function(error){
    if(!error){
      deferred.resolve();
      console.log("socket authorized");
    }
    if(error && app.getMetaMap().errorHandler)
      app.getMetaMap().errorHandler(error);

    app.setAuthStarted(false); // flushing of operations is done
  });
  return deferred.promise;
};

function setupAllSubscribersPromise(newApp) {
  var array = Object
              .keys(newApp.getMetaMap())
              .filter(extractSubscribers);
  return when.map(array, function(str) {
    return when.resolve(newApp.getMetaMap()[str](newApp.getSocket())); // invoke the registered subscriber
  });
}

function flushAdhocOperation(newApp){
  newApp
    .getAdhocOperations()
    .map(function(fn){
      fn(newApp.getSocket());
    });
  newApp.options.socketData.adhocOperations = [];
}

function extractSubscribers(str) {
  if (str.indexOf('subscription') === 0)
    return true;
  return false;
}

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>

  Disables realtime connection, all request to server would be done using HTTP.
  @memberof App
  @function disableRealtime
  @instance
  @example
  var app = Built
              .App('api_key')
              .enableRealtime(); // Return a app in which realtime is enabled

  app  = app
          .disalbeRealtime(); // Returns a new app instance on which realtime is disabled.
  @return {App}
*/
function disableRealtime(){
  var app    = this;
  var newApp = emptySocketData(app);
  newApp     = newApp
                .setAdaptor(Built.Adaptor.HTTP);
  return newApp;                
}

function emptySocketData(app) {
  var options               = app.getOptions();
  var newOptions            = R.mixin({}, options);
  var newSocketData         = R.mixin({}, options.socketData)
  newSocketData             = null;
  newOptions['socketData']  = null;
  return app.setOptions(newOptions);
}

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>

  Checks whether realtime is enabled on this app instance.
  @memberof App
  @function isRealtimeEnabled
  @instance
  @example
  var app = Built
              .App('api_key')
              .enableRealtime(); // Returns a app in which realtime is enabled

  var bool  = app
          .isRealtimeEnabled();
  @return {Boolean}
*/
function isRealtimeEnabled(){
  return !! this.getSocket();
}

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>

  The callback function provided to this method would invoked everytime a error occurs in realtime.
  @memberof App
  @function onRealtimeError
  @instance
  @example
  var app = Built
              .App('api_key')
              .enableRealtime()
              .onRealtimeError(function(error){
                  // e.g invalid application_key.
              }); 
*/
function onRealtimeError(callback){
  if(this.getMetaMap())
    this.getMetaMap()['errorHandler'] = callback;
}

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>
  This function registers a event listener on Object constructor. 
  </br>
  </br>
  <p><u>List of supported events are listed below.</u></p>
  <ul>
    <li><b>Create</b></li >
     <p> Create event is triggered when, a new object is created in the class with which the Object constructor is associated. Registered callback is invoked with created object.</p>

    <li><b>Update</b></li >
     <p> Update event is triggered when, any object in the class with which the Object constructor is associated is modified. Registered callback is invoked with updated object.</p>

    <li><b>Delete</b></li>
     <p> Delete event is triggered when, any object in the class with which the Object constructor is associated is deleted. Registered callback is invoked with deleted object.</p>

    <li><b>Broadcast</b></li>
     <p> Broadcast event is triggered when, a message is broadcasted for all object belong to a particular class. Registered callback is invoked with the broadcasted message.</p>
  </ul >

  @memberof Object
  @function on
  @param {String} event The event on which listener should be registered.
  @param {Function} callback The callback function to be invoked on event trigger.
  @static
  @example
    var app    = Built.App('api_key').enableRealtime();
    var Person =  app.Class('person').Object;

    Person.on('create', function(person) {
        // created person object
    });
    Person.on('update', function(person) {
        // updated person object
    });
    Person.on('delete', function(person) {
        // deleted person object
    });
    Person.on('broadcast', function(message) {
        // The message broadcasted for all objects of person class
    });
    @return {Object}
*/

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>
  This function registers a event listener on Object instance.
  </br>
  </br>
  <p><u>List of supported events are listed below.</u></p>
  <ul>
    <li><b>Update</b></li >
     <p> Update event is triggered when, contents or ACL of this object are modified. Registered callback is invoked with updated object.</p>

    <li><b>Delete</b></li>
     <p> Delete event is triggered when, object is deleted from built.io. Registered callback is invoked with deleted object.</p>

    <li><b>Broadcast</b></li>
     <p> Broadcast event is triggered when, a message is broadcasted over this object. Registered callback is invoked with the broadcasted message.</p>
  </ul >

  @memberof Object
  @function on
  @param {String} event The event on which listener should be registered.
  @param {Function} callback The callback function to be invoked on event trigger.
  @instance
  @throws new Error("Uid not found");
  @example
    var app    = Built.App('api_key').enableRealtime();
    var person =  app.Class('person').Object();
    person.on('update', function(person) {
        // updated person object
    });
    person.on('delete', function(person) {
        // deleted person object
    });
    person.on('broadcast', function(message) {
        // The message broadcasted on this object
    });
  @return {Object}
*/


/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>
  This function registers a event listener on Class constructor. 
  </br>
  </br>
  <p><u>List of supported events are listed below.</u></p>
  <ul>
    <li><b>Create</b></li >
     <p> Create event is triggered when, a new class is created in this application. Registered callback is invoked with created class data.</p>

    <li><b>Update</b></li >
     <p> Update event is triggered when, any class in this application is modified. Registered callback is invoked with updated class data.</p>

    <li><b>Delete</b></li>
     <p> Delete event is triggered when, any class in this application is deleted. Registered callback is invoked with deleted class data.</p>

    <li><b>Broadcast</b></li>
     <p> Broadcast event is triggered when, a message is broadcasted for all classes belonging to this application. Registered callback is invoked with the broadcasted message.</p>
  </ul >

  @memberof Class
  @function on
  @param {String} event The event on which listener should be registered.
  @param {Function} callback The callback function to be invoked on event trigger.
  @static
  @example
    var app     = Built.App('api_key').enableRealtime();
    var ClsCons =  app.Class;

    ClsCons.on('create', function(jsonObject) {
        // newly created class data
    });
    ClsCons.on('update', function(jsonObject) {
        // updated class data
    });
    ClsCons.on('delete', function(jsonObject) {
        // deleted class data
    });
    ClsCons.on('broadcast', function(message) {
        // The message broadcasted for all classes of this application
    });
   @return {Class} 
*/

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>
  This function registers a event listener on Class instance. 
  </br>
  </br>
  <p><u>List of supported events are listed below.</u></p>
  <ul>

    <li><b>Update</b></li >
     <p> Update event is triggered when, schema and/or acl of this class is modified. Registered callback is invoked with updated class data.</p>

    <li><b>Delete</b></li>
     <p> Delete event is triggered when, this class is deleted. Registered callback is invoked with deleted class data.</p>

    <li><b>Broadcast</b></li>
     <p> Broadcast event is triggered when, a message is broadcasted over the class instance. Registered callback is invoked with the broadcasted message.</p>
  </ul >

  @memberof Class
  @function on
  @param {String} event The event on which listener should be registered.
  @param {Function} callback The callback function to be invoked on event trigger.
  @instance
  @throws new Error("Uid not found");
  @example
    var app     = Built.App('api_key').enableRealtime();
    var Person =  app.Class('Person');

    Person.on('update', function(jsonObject) {
        // updated class data.
    });
    Person.on('delete', function(jsonObject) {
        // deleted class data.
    });
    Person.on('broadcast', function(message) {
        // The message broadcasted over this class.
    });
    @return {Class} 
*/

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>
  This function registers a event listener on Upload constructor. 
  </br>
  </br>
  <p><u>List of supported events are listed below.</u></p>
  <ul>
    <li><b>Create</b></li >
     <p> Create event is triggered when, a new upload is made over this application. Registered callback is invoked with the uploaded data.</p>

    <li><b>Update</b></li >
     <p> Update event is triggered when, contents or ACL of any upload on this application is modified . Registered callback is invoked with updated upload data.</p>

    <li><b>Delete</b></li>
     <p> Delete event is triggered when, any upload on this application is deleted. Registered callback is invoked with deleted upload data.</p>

    <li><b>Broadcast</b></li>
     <p> Broadcast event is triggered when, a message is broadcasted across all uploads. Registered callback is invoked with the broadcasted message.</p>
  </ul >

  @memberof Upload
  @function on
  @param {String} event The event on which listener should be registered.
  @param {Function} callback The callback function to be invoked on event trigger.
  @static
  @example
    var app     = Built.App('api_key').enableRealtime();
    var Upload =  app.Upload;

    Upload.on('create', function(jsonObject) {
        // newly created upload.
    });
    Upload.on('update', function(jsonObject) {
        // updated upload data.
    });
    Upload.on('delete', function(jsonObject) {
        // deleted upload data.
    });
    Upload.on('broadcast', function(message) {
        // The message broadcasted across over all uploads on this application.
    });
    @return {Upload} 
*/

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>
  This function registers a event listener on Upload instance. 
  </br>
  </br>
  <p><u>List of supported events are listed below.</u></p>
  <ul>
    <li><b>Update</b></li >
     <p> Update event is triggered when, contents or ACL of a upload on this application is modified . Registered callback is invoked with updated upload data.</p>

    <li><b>Delete</b></li>
     <p> Delete event is triggered when, a upload on this application is deleted. Registered callback is invoked with deleted upload data.</p>

    <li><b>Broadcast</b></li>
     <p> Broadcast event is triggered when, a message is broadcasted over this upload instance. Registered callback is invoked with the broadcasted message.</p>
  </ul >

  @memberof Upload
  @function on
  @param {String} event The event on which listener should be registered.
  @param {Function} callback The callback function to be invoked on event trigger.
  @instance
  @example
    var app     = Built.App('api_key').enableRealtime();
    var upload  =  app.Upload();

    upload.on('update', function(jsonObject) {
        // updated upload data.
    });
    upload.on('delete', function(jsonObject) {
        // deleted upload data.
    });
    upload.on('broadcast', function(message) {
        // The message broadcasted across over this upload instance.
    });
  @return {Upload} 
*/

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>
  This function registers a event listener on User constructor. 
  </br>
  </br>
  <p><u>List of supported events are listed below.</u></p>
  <ul>

    <li><b>Create</b></li >
     <p> Create event is triggered when, a new application user is created on this application. Registered callback is invoked with the created user's details.</p>

    <li><b>Update</b></li >
     <p> Update event is triggered when, contents or ACL of any user object on this application is modified . Registered callback is invoked with updated user's details.</p>

    <li><b>Delete</b></li>
     <p> Delete event is triggered when, any user object on this application is deleted. Registered callback is invoked with deleted user's details.</p>

    <li><b>Broadcast</b></li>
     <p> Broadcast event is triggered when, a message is broadcasted across all user objects. Registered callback is invoked with the broadcasted message.</p>

    <li><b>{@link Presence}</b></li >
     <p> Presence event is triggered when, a user state is changed, such user logins or logs out (You need to first request for presence update, which can be done using the requestPresenceAccess() on user instance.) </p>
  </ul >

  @memberof User
  @function on
  @param {String} event The event on which listener should be registered.
  @param {Function} callback The callback function to be invoked on event trigger.
  @static
  @example
    var app  = Built.App('api_key').enableRealtime();
    var User =  app.User;

    User.on('create', function(jsonObject) {
      // newly created user's details.
    });
    User.on('update', function(jsonObject) {
      // updated user's details.
    });
    User.on('delete', function(jsonObject) {
      // deleted user's details.
    });
    User.on('broadcast', function(message) {
      // The message broadcasted across all user objects.
    });
    User.on('presence', function(presence){
      console.log(presence.toJSON()); // Currently logged-in users presence details
    });
    @return {User} 
*/

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>
  This function registers a event listener on User instance. 
  </br>
  </br>
  <p><u>List of supported events are listed below.</u></p>
  <ul>

    <li><b>Update</b></li >
     <p> Update event is triggered when, contents or ACL of a user object on this application is modified . Registered callback is invoked with updated user's details.</p>

    <li><b>Delete</b></li>
     <p> Delete event is triggered when, a user object on this application is deleted. Registered callback is invoked with deleted user's details.</p>

    <li><b>Broadcast</b></li>
     <p> Broadcast event is triggered when, a message is broadcasted over this user object. Registered callback is invoked with the broadcasted message.</p>

  </ul >

  @memberof User
  @function on
  @param {String} event The event on which listener should be registered.
  @param {Function} callback The callback function to be invoked on event trigger.
  @instance
  @example
    var app  = Built.App('api_key').enableRealtime();
    var user =  app.User('abc123'); //abc123 is user's uid

    user.on('update', function(jsonObject) {
      // updated user's details.
    });
    user.on('delete', function(jsonObject) {
      // deleted user's details.
    });
    user.on('broadcast', function(message) {
      // The message broadcasted across this user object.
    });
    @return {User} 
*/

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>
  This function registers a event listener on Installation constructor. 
  </br>
  </br>
  <p><u>List of supported events are listed below.</u></p>
  <ul>

    <li><b>Create</b></li >
     <p> Create event is triggered when, a new installation is created on this application. Registered callback is invoked with the created installation's details.</p>

    <li><b>Update</b></li >
     <p> Update event is triggered when, contents or ACL of any installation object on this application is modified . Registered callback is invoked with updated installation's details.</p>

    <li><b>Delete</b></li>
     <p> Delete event is triggered when, any installation object on this application is deleted. Registered callback is invoked with deleted installation's details.</p>

    <li><b>Broadcast</b></li>
     <p> Broadcast event is triggered when, a message is broadcasted across all installation objects. Registered callback is invoked with the broadcasted message.</p>
  </ul >

  @memberof Installation
  @function on
  @param {String} event The event on which listener should be registered.
  @param {Function} callback The callback function to be invoked on event trigger.
  @static
  @example
    var app          = Built.App('api_key').enableRealtime();
    var Installation =  app.Installation;

    Installation.on('create', function(jsonObject) {
      // newly created installation's details.
    });
    Installation.on('update', function(jsonObject) {
      // updated installation's details.
    });
    Installation.on('delete', function(jsonObject) {
      // deleted installation's details.
    });
    Installation.on('broadcast', function(message) {
      // The message broadcasted across all installation objects.
    });
    @return {Installation} 
*/

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>
  This function registers a event listener on Installation instance. 
  </br>
  </br>
  <p><u>List of supported events are listed below.</u></p>
  <ul>

    <li><b>Update</b></li >
     <p> Update event is triggered when, contents or ACL of a user object on this application is modified . Registered callback is invoked with updated user's details.</p>

    <li><b>Delete</b></li>
     <p> Delete event is triggered when, a user object on this application is deleted. Registered callback is invoked with deleted user's details.</p>

    <li><b>Broadcast</b></li>
     <p> Broadcast event is triggered when, a message is broadcasted over this user object. Registered callback is invoked with the broadcasted message.</p>

  </ul >

  @memberof Installation
  @function on
  @param {String} event The event on which listener should be registered.
  @param {Function} callback The callback function to be invoked on event trigger.
  @instance
  @example
    var app  = Built.App('api_key').enableRealtime();
    var installation =  app.Installation('abc123'); //abc123 is user's uid

    installation.on('update', function(jsonObject) {
      // updated installation's details.
    });
    installation.on('delete', function(jsonObject) {
      // deleted installation's details.
    });
    installation.on('broadcast', function(message) {
      // The message broadcasted across this installation object.
    });
    @return {Installation} 
*/

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>
  Fetches currently logged-in user's presence details.
  @memberof User
  @function getPresence
  @static
  @throws new Error("Uid not found");
  @example
    var app  = Built.App('api_key').enableRealtime();
    var user =  app.User('abc'); // abc is user's uid
    
    user
      .getPresence()
        .then(function(presence){
          console.log(presence.toJSON()); // this user's presences details.
          // Refer presence module for more methods
        });
  @return {Promise<Presence>}
*/

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>
  In chat applications you can see someone else's presence details such as "last seen" timestamp. Similar functionality could be achieved using this method. The user object on which the method is invoked retrieves that user's presence details. (You need to first request for presence details using requestPresenceAccess method).
  @memberof User
  @function getPresence
  @instance
  @throws new Error("Uid not found");
  @example
    var app  = Built.App('api_key').enableRealtime();
    var user =  app.User('abc'); // abc is user's uid
    
    user
      .getPresence()
        .then(function(presence){
          console.log(presence.toJSON()); // this user's presences details.
        });
  @return {Promise<Presence>}
*/

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>
  In many applications you require to request another user for access to their presence. Similar functionality could be achieved using this method.  You can request a certain user for access to his presence. Target user can know about these requests when he fetches his own presence using User.getPresence() method.
  @memberof User
  @function requestPresenceAccess
  @instance
  @throws new Error("Uid not found");
  @example
    var app  = Built.App('api_key').enableRealtime();
    var user =  app.User('abc'); // abc is user's uid
    
    user
      .requestPresenceAccess()
        .then(function(){
          // done
        });
  @return {null}
*/

/*
  =============================OFF============================
*/

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>
  This function unregisters a single or all event listener(s) from Object constructor. 
  </br>
  </br>
  @memberof Object
  @function off
  @throws new Error('Callback function to be removed is missing')
  @throws new Error('Event name is missing');
  @param {String} event The event whose listener should be unregistered. [Optional]
  @param {Function} callback The callback function used while registring. [Optional]
  @static
  @example
    var app    = Built.App('api_key').enableRealtime();
    var Person =  app.Class('person').Object;
    
    function cb(data){
      console.log(data);
    }

    Person.on('delete',cb);   // Sets up a listener for create event.

    Person.on('broadcast',cb);  // Sets up a listener for broadcast event.

    Person.off('delete',cb); // Removes delete listener specifically.

    Person.off();           // Removes all listeners on Person.

    Person.off('delete');  // Would remove all callbacks attached for delete event on this resource

    Person.off(cb)            // Throws Event name is missing.

    @return {Object}
*/

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>
  This function unregisters a single or all event listener(s) from Object instance. 
  </br>
  </br>
  @memberof Object
  @function off
  @throws new Error('Callback function to be removed is missing')
  @throws new Error('Event name is missing');
  @param {String} event The event whose listener should be unregistered. [Optional]
  @param {Function} callback The callback function used while registring. [Optional]
  @instance
  @example
    var app    = Built.App('api_key').enableRealtime();
    var person = app.Class('person').Object('abc123');
    
    function cb(data){
      console.log(data);
    }

    person.on('delete',cb);   // Sets up a listener for create event.

    person.on('broadcast',cb);  // Sets up a listener for broadcast event.

    person.off('delete',cb); // Removes delete listener specifically.

    person.off();           // Removes all listeners on Person.

    person.off('delete');  // Would remove all callbacks attached for delete event on this resource

    person.off(cb)            // Throws Event name is missing.

    @return {Object}
*/

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>
  This function unregisters a single or all event listener(s) from User constructor. 
  </br>
  </br>
  @memberof User
  @function off
  @throws new Error('Callback function to be removed is missing')
  @throws new Error('Event name is missing');
  @param {String} event The event whose listener should be unregistered. [Optional]
  @param {Function} callback The callback function used while registring. [Optional]
  @static
  @example
    var app    = Built.App('api_key').enableRealtime();
    var User   = app.User;
    
    function cb(data){
      console.log(data);
    }

    User.on('delete',cb);   // Sets up a listener for create event.

    User.on('broadcast',cb);  // Sets up a listener for broadcast event.

    User.off('delete',cb); // Removes delete listener specifically.

    User.off();           // Removes all listeners on Person.

    User.off('delete');  // Would remove all callbacks attached for delete event on this resource

    User.off(cb)            // Throws Event name is missing.

    @return {User}
*/

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>
  This function unregisters a single or all event listener(s) from User instance. 
  </br>
  </br>
  @memberof User
  @function off
  @throws new Error('Callback function to be removed is missing')
  @throws new Error('Event name is missing');
  @param {String} event The event whose listener should be unregistered. [Optional]
  @param {Function} callback The callback function used while registring. [Optional]
  @instance
  @example
    var app  = Built.App('api_key').enableRealtime();
    var user = app.User('abc123');
    
    function cb(data){
      console.log(data);
    }

    user.on('delete',cb);   // Sets up a listener for create event.

    user.on('broadcast',cb);  // Sets up a listener for broadcast event.

    user.off('delete',cb); // Removes delete listener specifically.

    user.off();           // Removes all listeners on Person.

    user.off('delete');  // Would remove all callbacks attached for delete event on this resource

    user.off(cb)            // Throws Event name is missing.

    @return {User}
*/

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>
  This function unregisters a single or all event listener(s) from Class constructor. 
  </br>
  </br>
  @memberof Class
  @function off
  @throws new Error('Callback function to be removed is missing')
  @throws new Error('Event name is missing');
  @param {String} event The event whose listener should be unregistered. [Optional]
  @param {Function} callback The callback function used while registring. [Optional]
  @static
  @example
    var app    = Built.App('api_key').enableRealtime();
    var Class  = app.Class;
    
    function cb(data){
      console.log(data);
    }

    Class.on('delete',cb);   // Sets up a listener for create event.

    Class.on('broadcast',cb);  // Sets up a listener for broadcast event.

    Class.off('delete',cb); // Removes delete listener specifically.

    Class.off();           // Removes all listeners on Person.

    Class.off('delete');  // Would remove all callbacks attached for delete event on this resource

    Class.off(cb)            // Throws Event name is missing.

    @return {Class}
*/

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>
  This function unregisters a single or all event listener(s) from Class instance. 
  </br>
  </br>
  @memberof Class
  @function off
  @throws new Error('Callback function to be removed is missing')
  @throws new Error('Event name is missing');
  @param {String} event The event whose listener should be unregistered. [Optional]
  @param {Function} callback The callback function used while registring. [Optional]
  @instance
  @example
    var app    = Built.App('api_key').enableRealtime();
    var person = app.Class('person');
    
    function cb(data){
      console.log(data);
    }

    person.on('delete',cb);   // Sets up a listener for create event.

    person.on('broadcast',cb);  // Sets up a listener for broadcast event.

    person.off('delete',cb); // Removes delete listener specifically.

    person.off();           // Removes all listeners on Person.

    person.off('delete');  // Would remove all callbacks attached for delete event on this resource

    person.off(cb)            // Throws Event name is missing.

    @return {Class}
*/

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>
  This function unregisters a single or all event listener(s) from Role constructor. 
  </br>
  </br>
  @memberof Role
  @function off
  @throws new Error('Callback function to be removed is missing')
  @throws new Error('Event name is missing');
  @param {String} event The event whose listener should be unregistered. [Optional]
  @param {Function} callback The callback function used while registring. [Optional]
  @static
  @example
    var app    = Built.App('api_key').enableRealtime();
    var Role   = app.Role;
    
    function cb(data){
      console.log(data);
    }

    Role.on('delete',cb);   // Sets up a listener for create event.

    Role.on('broadcast',cb);  // Sets up a listener for broadcast event.

    Role.off('delete',cb); // Removes delete listener specifically.

    Role.off();           // Removes all listeners on Person.

    Role.off('delete');  // Would remove all callbacks attached for delete event on this resource

    Role.off(cb)            // Throws Event name is missing.

    @return {Role}
*/

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>
  This function unregisters a single or all event listener(s) from Role instance. 
  </br>
  </br>
  @memberof Role
  @function off
  @throws new Error('Callback function to be removed is missing')
  @throws new Error('Event name is missing');
  @param {String} event The event whose listener should be unregistered. [Optional]
  @param {Function} callback The callback function used while registring. [Optional]
  @instance
  @example
    var app  = Built.App('api_key').enableRealtime();
    var role = app.Role('abc123');
    
    function cb(data){
      console.log(data);
    }

    role.on('delete',cb);   // Sets up a listener for create event.

    role.on('broadcast',cb);  // Sets up a listener for broadcast event.

    role.off('delete',cb); // Removes delete listener specifically.

    role.off();           // Removes all listeners on Person.

    role.off('delete');  // Would remove all callbacks attached for delete event on this resource

    role.off(cb)            // Throws Event name is missing.

    @return {Role}
*/

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>
  This function unregisters a single or all event listener(s) from Installation constructor. 
  </br>
  </br>
  @memberof Installation
  @function off
  @throws new Error('Callback function to be removed is missing')
  @throws new Error('Event name is missing');
  @param {String} event The event whose listener should be unregistered. [Optional]
  @param {Function} callback The callback function used while registring. [Optional]
  @static
  @example
    var app    = Built.App('api_key').enableRealtime();
    var Installation   = app.Installation;
    
    function cb(data){
      console.log(data);
    }

    Installation.on('delete',cb);   // Sets up a listener for create event.

    Installation.on('broadcast',cb);  // Sets up a listener for broadcast event.

    Installation.off('delete',cb); // Removes delete listener specifically.

    Installation.off();           // Removes all listeners on Person.

    Installation.off('delete');  // Would remove all callbacks attached for delete event on this resource

    Installation.off(cb)            // Throws Event name is missing.

    @return {Installation}
*/

/**
  <p class="text-danger"> 
      [Only avaliable with realtime plugin]
  </p>
  This function unregisters a single or all event listener(s) from Installation instance. 
  </br>
  </br>
  @memberof Installation
  @function off
  @throws new Error('Callback function to be removed is missing')
  @throws new Error('Event name is missing');
  @param {String} event The event whose listener should be unregistered. [Optional]
  @param {Function} callback The callback function used while registring. [Optional]
  @instance
  @example
    var app  = Built.App('api_key').enableRealtime();
    var installation = app.Installation('abc123');
    
    function cb(data){
      console.log(data);
    }

    installation.on('delete',cb);   // Sets up a listener for create event.

    installation.on('broadcast',cb);  // Sets up a listener for broadcast event.

    installation.off('delete',cb); // Removes delete listener specifically.

    installation.off();           // Removes all listeners on Person.

    installation.off('delete');  // Would remove all callbacks attached for delete event on this resource

    installation.off(cb)            // Throws Event name is missing.

    @return {Installation}
*/
